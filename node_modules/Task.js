var FlowState = {
    INITIAL: 0,
    STARTED: 1,
    SUSPENDED: 2,
    ENDED: 3,
    ENDED_RESUME: 4
};

var FlowCallback = function (callback) {
    this.callback = callback;
    this.state = FlowState.INITIAL;
};

FlowCallback.prototype.begin = function () {
    if (this.state != FlowState.INITIAL) {
        throw new Error("not INITIAL");
    }
    this.state = FlowState.STARTED;
};
    
FlowCallback.prototype.suspend = function () {
    if (this.state != FlowState.STARTED) {
        throw new Error("not STARTED");
    }
    this.state = FlowState.SUSPENDED;
};
    
FlowCallback.prototype.resume = function () {
    if (this.state != FlowState.SUSPENDED) {
        throw new Error("not SUSPENDED");
    }
    this.state = FlowState.ENDED_RESUME;
    if (this.callback) this.callback();
};

FlowCallback.prototype.end = function () {
    if (this.state == FlowState.STARTED) {
        this.state = FlowState.ENDED;
        if (this.callback) this.callback();
    } else if (this.state != FlowState.SUSPENDED && this.state != FlowState.ENDED_RESUME) {
        throw new Error("not endable");
    }
};

var runTask = function (flow, task, args) {
    flow.begin();
    args = Array.prototype.slice.call(args);
    args.unshift(flow);
    task.apply(null, args);
    flow.end();
};

function decorate(task) {
    if (task instanceof Task) return task; 
    if (!task) task = function () {};
    return new Task(task);
}

var Task = function (task) {
    this.task = task;
};

Task.prototype.start = function () {
    runTask(new FlowCallback(), this.task, arguments);
};
    
Task.prototype.then = function (after) {
    after = decorate(after);
    var first = this;
    return new Task(function () {
        var flow = arguments[0];
        var args = Array.prototype.slice.call(arguments, 1);
        var firstFlow = new FlowCallback(function () {
            var afterFlow = new FlowCallback(function () { flow.resume(); });
            runTask(afterFlow, after.task, args);
        });
        flow.suspend();
        runTask(firstFlow, first.task, args);
    });
};

Task.If = function(condition, blockTrue, blockFalse) {
    return new Task(function (flow) {
        flow.suspend();
        var block = decorate(condition()? blockTrue: blockFalse);
        block
            .then(function () { flow.resume(); })
            .start();
    });
};

Task.While = function (condition, iteration) {
    iteration = decorate(iteration);
    var iterate = function (flow) {
        Task.If(
            condition,
            iteration
                .then(function () {
                    iterate(flow);
                }),
            function () {
                flow.resume();
            }
        ).start();
    };
    return new Task(function (flow) {
        flow.suspend();
        iterate(flow);
    });
};

Task.For = function (condition, increment, iteration) {
    iteration = decorate(iteration);
    return Task.While(condition, iteration.then(increment));
};

Task.ForRange = function (start, end, iteration) {
    iteration = decorate(iteration);
    var i = start;
    return Task.For(
        function () { return i <= end; },
        function () { i++; },
        function (flow) {
            flow.suspend();
            iteration.then(function () { flow.resume(); }).start(i);
        }
    );
};

Task.ForEach = function (array, iteration) {
    iteration = decorate(iteration);
    var i = 0;
    return Task.For(
        function () { return i < array.length; },
        function () { i++; },
        function (flow) {
            flow.suspend();
            iteration.then(function () { flow.resume(); }).start(array[i]);
        }
    );
};

Task.WaitFor = function (condition, timeout) {
    return Task.While(
        function () { return !condition(); },
        function (flow) {
            flow.suspend();
            setTimeout(function () { flow.resume(); }, timeout || 50);
        }
    );
};

Task.Closure = function (closure) {
    return new Task(function (flow) {
        flow.suspend();
        closure().then(function () { flow.resume(); }).start();
    });
};

module.exports = Task;
